# 알고리즘 리뷰



유의 사항

1. 잔 실수를 줄이자 





## DFS  & BFS 

깊이 우선 탐색, 너비 우선 탐색



* 1987 알파벳 
  * BFS : visited로 방문 여부를 확인하는게 주어진 board에 알파벳으로 방문 여부를 처리한다. 따라서 중복을 피하기 위해 que를 set으로 설정해 메모리 초과와 시간 복잡도 초과를 해결한다. 



* 2583 영역 구하기
  * 범위의 제대로 된 변수를 넣었는지 확인하자.. 



* 4963 섬의 개수

  * DFS를 쓸 떄 파이썬이 정해놓은 재귀 깊이를 넘으면 발생하는 에러. 런타임에러 : RecursionError 가 발생할 수 있다.

    이를 해결하기 위해  sys.setrecursionlimit(10000) 을 추가하면 된다. 



* 1520 내리막 길
  * 목적지까디 도착하는 경우의 수를 구하는 문제.
  * 이런 문제는 완전 탐색이나 BFS를 쓰면 시간 초과의 문제가 발생할 수 있다.
  * 그러므로 DFS와 DP를 조합해서 해결해야 한다.
  * DFS로 목적지까지 가는 길을 뚫은 다음 DP를 이용해 다른 경로가 정답까지 가는 경로와 곂치면 +1을 하고 더 이상 탐색을 하지 않는 방법을 사용한다. 
  * 코드의 과정이 복잡하니까 여러번 공부를 통해 익숙해저야 한다.
  * 나중에 시간이 되면 BFS , DP의 조합으로도 풀고 싶은데 BFS는 정답길을 먼저 찾는게 아니라 힘들거 같다.. 



* 2644 촌수계산
  * BFS를 푸는 과정에서 que.append([moum.append(i)]) 를 사용했는데 작동되지 않았다. append 과정을 한 다음에 que에 집어넣으니 해결되었다. 



* 2667 단지번호붙이기
  * que에 넣는 것 대신 dfs(ny, nx)를 사용하면 dfs 탐색을 구현할 수 있다. 